哈希/散列
:本质上就是映射，找到一个值进行映射

计数排序：
1.统计每个数字出现次数，范围很集中，可以，随机的一堆整数，就按照范围来开空间，很分散，最好不要这样，


除留余数法
10 122 31 400
%10把数字放到它余数对应的位置

开10个空间，分配到不同的地方
哈希冲突：

不同的数用哈希放到了同一个地方,不能保证每个值都开辟一个空间
但是我想要映射到一个相对固定的地方去

如何解决哈希冲突
1. 闭散列
>闭散列：开放定址法，当发生hash冲突的时候，如果哈希表未被装满，说明在哈希表中必然还有空的位置，那么就把key存放到下一个“空位置”中去
    * 线性探测
    >从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止

    * 二次探测
    >
2.开散列/哈希桶/拉链法 
6 26  36 46，
把尾数为6的都挂起来，这样就不会出现争抢位置，现在我们出现的争抢就内部解决，不会互相影响了，从根源上更好的去管理这个东西


表长度100

控制负载因子，能够极大的控制住效率--负载因子到了就扩容
但一个桶的长度超过一定的值之后，就把他转化成一个红黑树,这样效率就很高了
~~~cpp
//极端场景下
struct Date
{
    forward_list<T> _list;
    set<T> _list;
    size_t len
};
len 大于一定值的时候，就把forward_list 里面的数据插入到set里面，再把单链表里面的数据给删除掉

~~~

极端场景
1. 存50个值，40个值冲突，挂在同一个桶上
2. 存储了10000个值，平均每个桶的长度100，阶段场景山有些桶可能有上千个值

# 哈希函数
* 除留余数法
* 平方取中法
>假如关键字1234，就把它平方=1522356，取中间3位，223，
>如果它不够3位，就继续对他进行平方，直到取出3位位置，也存在哈希冲突
>不常用

* 数学分析法
